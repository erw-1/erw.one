<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GeoParquet Viewer (experimental)</title>
  <!-- OpenLayers CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@latest/ol.css">
  <style>
    /* Copy your existing SCSS styles here */
    html,
    body,
    #viewer {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: sans-serif;
    }

    #header {
      height: 4rem;
      background-color: #333;
      color: #fff;
    }

    .row {
      height: 2rem;
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 0 0.5rem;
      box-sizing: border-box;
    }

    .title {
      margin: 0;
      padding: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex-grow: 1;
    }

    button {
      white-space: nowrap;
      padding: 0.5rem 1rem;
      cursor: pointer;
    }

    .subheader {
      background-color: #777;
    }

    #main {
      height: calc(100% - 4rem);
      display: flex;
      flex-direction: column;
    }

    #error-container,
    #table-container,
    #map-container {
      width: 100%;
      flex: 1;
      overflow: auto;
    }

    #error-container {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
    }

    thead {
      position: sticky;
      top: 0;
      background-color: #ccc;
      box-shadow: 0 2px 2px -1px rgba(0, 0, 0, 0.4);
    }

    tr:nth-child(odd) {
      background-color: #f2f2f2;
    }

    tr.highlight {
      background-color: #ff9999 !important;
    }

    th, td {
      border: 1px solid #555;
      font-size: 0.8rem;
      max-width: 10rem;
      padding: 0.3rem;
      box-sizing: border-box;
    }

    td > div {
      width: 100%;
      height: 100%;
      max-height: 3rem;
      overflow: auto;
      word-wrap: break-word;
    }

    .loadmore {
      text-align: center;
      padding: 0.5rem;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    #loading {
      position: fixed;
      bottom: 1rem;
      left: 1rem;
      width: 5rem;
      height: 5rem;
      display: none;
      justify-content: center;
      align-items: center;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 50%;
    }

    /* Spinner Styles */
    .spinner {
      border: 8px solid #f3f3f3;
      border-top: 8px solid #333;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Modal Styles */
    .modal {
      display: none; /* Hidden by default */
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
    }

    .modal-content {
      background-color: #fefefe;
      margin: 10% auto;
      padding: 20px;
      border: 1px solid #888;
      width: 80%;
      max-width: 500px;
      border-radius: 5px;
    }

    .close {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }

    .close:hover,
    .close:focus {
      color: black;
      text-decoration: none;
    }
  </style>
</head>
<body>
  <div id="viewer">
    <header id="header">
      <div class="row">
        <h1 class="title">GeoParquet Viewer (experimental)</h1>
        <button id="loadDataBtn">Load Data</button>
        <button id="aboutBtn">About</button>
      </div>
      <div class="row subheader">
        <span class="title">
          <code id="urlDisplay"></code>
          &nbsp;
          <span class="counts" id="countsDisplay">
            (0 / ? rows
            <button id="loadMoreBtn" style="display:none;">Load more...</button>
          )
        </span>
        <button id="parquetMetadataBtn" style="display:none;">Parquet Metadata</button>
        <button id="geoMetadataBtn" style="display:none;">GeoParquet Metadata</button>
      </div>
    </header>
    <main id="main">
      <section id="error-container" style="display:none;">
        <p id="errorMessage"></p>
      </section>
      <section id="table-container" style="display:none;">
        <table id="table">
          <thead>
            <tr id="tableHeader"></tr>
          </thead>
          <tbody id="tableBody"></tbody>
        </table>
        <div class="loadmore" id="loadMoreContainer" style="display:none;">
          <button id="loadMoreBtn2">Load more...</button>&nbsp;
          <button id="loadAllBtn">Load all...</button>
        </div>
      </section>
      <section id="map-container">
        <div id="map"></div>
      </section>
    </main>
    <!-- Modals -->
    <div id="aboutModal" class="modal">
      <div class="modal-content">
        <span class="close" data-modal="aboutModal">&times;</span>
        <h2>About</h2>
        <p>GeoParquet Viewer is an experimental tool for viewing Parquet data with geospatial metadata.</p>
      </div>
    </div>

    <div id="loadDataModal" class="modal">
      <div class="modal-content">
        <span class="close" data-modal="loadDataModal">&times;</span>
        <h2>Load Data</h2>
        <form id="loadDataForm">
          <div class="row">
            <label for="dataUrl">Data URL:</label>
            <input type="text" id="dataUrl" name="dataUrl" required>
          </div>
          <button type="submit">Load</button>
        </form>
      </div>
    </div>

    <div id="metadataModal" class="modal">
      <div class="modal-content">
        <span class="close" data-modal="metadataModal">&times;</span>
        <h2>Metadata</h2>
        <pre id="metadataContent"></pre>
      </div>
    </div>

    <!-- Loading Spinner -->
    <div id="loading">
      <div class="spinner"></div>
    </div>
  </div>

  <!-- OpenLayers JS -->
  <script src="https://cdn.jsdelivr.net/npm/ol@latest/dist/ol.js"></script>
  <!-- Proj4 JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
  <!-- HyParquet and related dependencies -->
  <script src="https://unpkg.com/hyparquet@1.5.0/src/hyparquet.js"></script>
  <script src="https://unpkg.com/hyparquet-compressors@0.1.4/src/index.js"></script>
  <script src="https://unpkg.com/hysnappy@0.3.1/hysnappy.js"></script>
  <!-- Your custom map style -->
  <script>
    // getStyle function equivalent to your './map.js'
    function getStyle(color = '#3399CC') {
      return new ol.style.Style({
        image: new ol.style.Circle({
          radius: 5,
          fill: new ol.style.Fill({ color: color }),
          stroke: new ol.style.Stroke({
            color: '#fff',
            width: 1
          })
        }),
        stroke: new ol.style.Stroke({
          color: color,
          width: 2
        }),
        fill: new ol.style.Fill({
          color: color + '33'
        })
      });
    }
  </script>
  <script>
    (async () => {
      // State Management
      const state = {
        data: {},
        columns: [],
        offset: 0,
        pageSize: 100,
        fileSize: null,
        metadata: null,
        loading: false,
        selected: null,
        modals: []
      };

      // Elements
      const urlDisplay = document.getElementById('urlDisplay');
      const countsDisplay = document.getElementById('countsDisplay');
      const loadDataBtn = document.getElementById('loadDataBtn');
      const aboutBtn = document.getElementById('aboutBtn');
      const parquetMetadataBtn = document.getElementById('parquetMetadataBtn');
      const geoMetadataBtn = document.getElementById('geoMetadataBtn');
      const loadMoreBtn = document.getElementById('loadMoreBtn');
      const loadMoreBtn2 = document.getElementById('loadMoreBtn2');
      const loadAllBtn = document.getElementById('loadAllBtn');
      const tableHeader = document.getElementById('tableHeader');
      const tableBody = document.getElementById('tableBody');
      const errorContainer = document.getElementById('error-container');
      const errorMessage = document.getElementById('errorMessage');
      const tableContainer = document.getElementById('table-container');
      const loadMoreContainer = document.getElementById('loadMoreContainer');
      const loadingSpinner = document.getElementById('loading');

      // Modals
      const aboutModal = document.getElementById('aboutModal');
      const loadDataModal = document.getElementById('loadDataModal');
      const metadataModal = document.getElementById('metadataModal');
      const metadataContent = document.getElementById('metadataContent');

      // Map Setup
      const vectorSource = new ol.source.Vector();
      const vectorLayer = new ol.layer.Vector({
        source: vectorSource
      });

      const map = new ol.Map({
        target: 'map',
        layers: [
          new ol.layer.Tile({
            source: new ol.source.OSM()
          }),
          vectorLayer
        ],
        view: new ol.View({
          center: [0, 0],
          zoom: 2
        })
      });

      const selectInteraction = new ol.interaction.Select({
        style: getStyle('#FF0000')
      });

      map.addInteraction(selectInteraction);

      selectInteraction.on('select', (e) => {
        if (e.selected.length > 0) {
          const feature = e.selected[0];
          const id = parseInt(feature.getId(), 10);
          selectInTable(id);
        }
      });

      // Helper Functions
      function getDefaultUrl() {
        const urlParams = new URLSearchParams(window.location.search);
        const url = urlParams.get('url');
        if (url) {
          return url;
        } else {
          const relPath = './airports.parquet';
          const absPath = new URL(relPath, window.location.href);
          return absPath.toString();
        }
      }

      function showModal(modal) {
        modal.style.display = 'block';
      }

      function hideModal(modal) {
        modal.style.display = 'none';
      }

      function updateURL() {
        const url = state.url;
        const newURL = new URL(window.location);
        newURL.searchParams.set('url', url);
        window.history.pushState({}, '', newURL);
      }

      function showLoading() {
        loadingSpinner.style.display = 'flex';
      }

      function hideLoading() {
        loadingSpinner.style.display = 'none';
      }

      function showError(message) {
        errorMessage.textContent = message;
        errorContainer.style.display = 'flex';
        tableContainer.style.display = 'none';
      }

      function hideError() {
        errorContainer.style.display = 'none';
      }

      function updateCounts() {
        const loadedNumRows = state.columns.length > 0 && Array.isArray(state.data[state.columns[0]]) ? state.data[state.columns[0]].length : 0;
        const totalNumRows = state.metadata ? state.metadata.num_rows : -1;
        countsDisplay.innerHTML = `(${loadedNumRows} / ${totalNumRows >= 0 ? totalNumRows : '?'} rows`;
        if (!state.loading && !isComplete()) {
          loadMoreBtn.style.display = 'inline';
        } else {
          loadMoreBtn.style.display = 'none';
        }
      }

      function isComplete() {
        return state.loadedNumRows >= 0 && state.loadedNumRows >= state.totalNumRows;
      }

      function updateURLDisplay() {
        urlDisplay.textContent = state.url;
      }

      function renderTableHeader() {
        tableHeader.innerHTML = '';
        state.shownColumns.forEach(column => {
          const th = document.createElement('th');
          th.textContent = column;
          tableHeader.appendChild(th);
        });
      }

      function renderTableBody() {
        tableBody.innerHTML = '';
        const rowIndices = Array.from({ length: state.loadedNumRows }, (_, i) => i);
        rowIndices.forEach(i => {
          const tr = document.createElement('tr');
          tr.id = `row_${i}`;
          tr.addEventListener('click', () => selectOnMap(i));
          if (i === state.selected) {
            tr.classList.add('highlight');
          }
          state.shownColumns.forEach(column => {
            const td = document.createElement('td');
            const div = document.createElement('div');
            div.textContent = state.data[column][i];
            td.appendChild(div);
            tr.appendChild(td);
          });
          tableBody.appendChild(tr);
        });
      }

      function renderTable() {
        if (Object.keys(state.data).length === 0) {
          errorContainer.style.display = 'flex';
          tableContainer.style.display = 'none';
        } else {
          hideError();
          tableContainer.style.display = 'block';
          renderTableHeader();
          renderTableBody();
        }
      }

      function selectOnMap(i) {
        selectFeature(i);
        const row = document.getElementById(`row_${i}`);
        if (row) {
          row.scrollIntoView({ block: 'center' });
        }
      }

      function selectFeature(i) {
        if (state.selected !== null) {
          const prevFeature = vectorSource.getFeatureById(state.selected);
          if (prevFeature) {
            prevFeature.setStyle(getStyle());
          }
        }
        const feature = vectorSource.getFeatureById(i);
        if (feature) {
          feature.setStyle(getStyle('#FF0000'));
          const geometry = feature.getGeometry();
          const type = geometry.getType();
          let fitOpts;
          if (type === 'Point') {
            fitOpts = { minResolution: 1000 };
          } else {
            fitOpts = { padding: [100, 100, 100, 100] };
          }
          map.getView().fit(geometry.getExtent(), fitOpts);
          state.selected = i;
          renderTableBody();
        }
      }

      function selectInTable(i) {
        state.selected = i;
        renderTableBody();
      }

      function getAsyncBuffer() {
        return {
          byteLength: state.fileSize,
          slice: async (start, end) => {
            const rangeEnd = end === undefined ? '' : end - 1;
            const res = await fetch(state.url, {
              headers: {
                Range: `bytes=${start}-${rangeEnd}`
              }
            });
            return res.arrayBuffer();
          }
        };
      }

      async function loadProj(code) {
        if (proj4.defs(code)) {
          return;
        }
        try {
          const path = code.toLowerCase().replace(':', '/');
          const response = await fetch(`https://spatialreference.org/ref/${path}/ogcwkt/`);
          const wkt = await response.text();
          proj4.defs(code, wkt);
          ol.proj.proj4.register(proj4);
          return proj4.defs(code);
        } catch (error) {
          showError(`Failed to load projection ${code}: ${error.message}`);
        }
      }

      async function parseWKB() {
        const format = new ol.format.WKB();
        await loadProj(state.crs);
        const featureOpts = {
          dataProjection: state.crs,
          featureProjection: 'EPSG:3857'
        };
        for (const column in state.geoMetadata.columns) {
          for (const i in state.data[column]) {
            const wkb = state.data[column][i];
            const feature = format.readFeature(wkb, featureOpts);
            feature.setId(i);
            state.data[column][i] = feature;
          }
        }
      }

      async function addToMap() {
        for (const feature of state.data[state.geoMetadata.primary_column]) {
          vectorSource.addFeature(feature);
        }
        map.getView().fit(vectorSource.getExtent());
      }

      function getDefaults() {
        return {
          data: {},
          columns: [],
          offset: 0,
          pageSize: 100,
          fileSize: null,
          metadata: null,
          loading: false,
          selected: null,
          modals: []
        };
      }

      function resetState() {
        Object.assign(state, getDefaults(), {
          data: {},
          columns: state.columns, // Preserve columns if any
          selected: null
        });
        vectorSource.clear();
      }

      async function discover() {
        try {
          const head = await fetch(state.url, { method: 'HEAD' });
          if (!head.ok) {
            throw new Error(`Error (${head.status}) fetching file: ${head.statusText}`);
          }
          const size = head.headers.get('content-length');
          if (!size) {
            throw new Error('No content-length header returned by server');
          }
          state.fileSize = Number(size);
          state.metadata = await hyparquet.parquetMetadataAsync(getAsyncBuffer());
          if (state.columns.length === 0) {
            state.columns = state.columnsInSchema;
          }
        } catch (error) {
          showError(error.message);
        }
      }

      async function load() {
        resetState();
        await loadMore();
      }

      async function loadAll() {
        state.pageSize = 0;
        await loadMore();
      }

      async function loadMore() {
        if (isComplete()) {
          return;
        }
        state.loading = true;
        showLoading();
        try {
          if (state.fileSize === null) {
            await discover();
          }
          const rowStart = state.offset;
          let rowEnd = undefined;
          if (state.pageSize) {
            rowEnd = state.offset + state.pageSize;
          }
          state.columnsInSchema.forEach((column) => {
            if (!Array.isArray(state.data[column])) {
              state.data[column] = [];
            }
          });
          await hyparquet.parquetRead({
            file: getAsyncBuffer(),
            metadata: state.metadata,
            compressors: {
              ...hyparquetCompressors.compressors,
              snappy: hySnappy.snappyUncompressor()
            },
            columns: state.columns.length === 0 ? undefined : state.columns,
            rowStart,
            rowEnd,
            utf8: false,
            onChunk: ({ columnName, columnData }) => {
              if (state.pageSize) {
                columnData = columnData.slice(0, state.pageSize);
              }
              columnData.forEach(x => state.data[columnName].push(x));
            }
          });
          state.offset += state.pageSize;
          await parseWKB();
          await addToMap();
          state.loadedNumRows = state.data[state.columns[0]].length;
          renderTable();
          updateCounts();
        } catch (error) {
          showError(error.message);
        } finally {
          state.loading = false;
          hideLoading();
        }
      }

      // Computed Properties
      Object.defineProperty(state, 'loadedNumRows', {
        get: function() {
          const keys = Object.keys(this.data);
          if (keys.length > 0 && Array.isArray(this.data[keys[0]])) {
            return this.data[keys[0]].length;
          }
          return 0;
        }
      });

      Object.defineProperty(state, 'totalNumRows', {
        get: function() {
          return this.metadata?.num_rows || -1;
        }
      });

      Object.defineProperty(state, 'geoMetadata', {
        get: function() {
          const geo = this.metadata?.key_value_metadata?.find(md => md.key === 'geo');
          if (geo && geo.value) {
            return JSON.parse(geo.value);
          }
          return null;
        }
      });

      Object.defineProperty(state, 'primaryGeoColumn', {
        get: function() {
          if (this.geoMetadata) {
            return this.geoMetadata.columns[this.geoMetadata.primary_column];
          }
          return {};
        }
      });

      Object.defineProperty(state, 'schema', {
        get: function() {
          if (this.metadata) {
            return hyparquet.parquetSchema(this.metadata);
          }
          return null;
        }
      });

      Object.defineProperty(state, 'columnsInSchema', {
        get: function() {
          if (this.schema) {
            return this.schema.children.map(child => child.element.name);
          }
          return [];
        }
      });

      Object.defineProperty(state, 'shownColumns', {
        get: function() {
          return this.columns.filter(column => !(column in (this.geoMetadata?.columns || {})));
        }
      });

      Object.defineProperty(state, 'crs', {
        get: function() {
          const crs = this.primaryGeoColumn.crs;
          if (crs && crs.id) {
            return `${crs.id.authority}:${crs.id.code}`;
          }
          return 'EPSG:4326';
        }
      });

      // Event Listeners
      loadDataBtn.addEventListener('click', () => showModal(loadDataModal));
      aboutBtn.addEventListener('click', () => showModal(aboutModal));
      parquetMetadataBtn.addEventListener('click', () => {
        metadataContent.textContent = JSON.stringify(state.metadata, null, 2);
        showModal(metadataModal);
      });
      geoMetadataBtn.addEventListener('click', () => {
        metadataContent.textContent = JSON.stringify(state.geoMetadata, null, 2);
        showModal(metadataModal);
      });
      loadMoreBtn2.addEventListener('click', loadMore);
      loadAllBtn.addEventListener('click', loadAll);

      // Modal Close Buttons
      document.querySelectorAll('.close').forEach(span => {
        span.addEventListener('click', () => {
          const modalId = span.getAttribute('data-modal');
          const modal = document.getElementById(modalId);
          hideModal(modal);
        });
      });

      // Load Data Form Submission
      document.getElementById('loadDataForm').addEventListener('submit', (e) => {
        e.preventDefault();
        const urlInput = document.getElementById('dataUrl').value;
        state.url = urlInput;
        updateURL();
        hideModal(loadDataModal);
        load();
      });

      // Initial Setup
      state.url = getDefaultUrl();
      updateURLDisplay();
      if (state.url) {
        load();
      }

      // Show/Hide Metadata Buttons based on availability
      Object.defineProperty(state, 'metadataAvailable', {
        get: function() {
          return !!this.metadata;
        }
      });

      Object.defineProperty(state, 'geoMetadataAvailable', {
        get: function() {
          return !!this.geoMetadata;
        }
      });

      // Watch for changes in metadata to show buttons
      const metadataObserver = new MutationObserver(() => {
        if (state.metadataAvailable) {
          parquetMetadataBtn.style.display = 'inline';
        }
        if (state.geoMetadataAvailable) {
          geoMetadataBtn.style.display = 'inline';
        }
      });

      metadataObserver.observe(metadataModal, { attributes: true, childList: true, subtree: true });

    })();
  </script>
</body>
</html>
