<!DOCTYPE html>
<html>
<head>
  <title>GeoParquet Viewer</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/proj4/dist/proj4.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/wellknown"></script>
</head>
<body>
  <h1>GeoParquet Viewer</h1>
  <input type="file" id="fileInput" accept=".parquet" />
  <br />
  Or load from URL:
  <input type="text" id="urlInput" placeholder="Enter GeoParquet URL" />
  <button id="loadButton">Load</button>
  <h3>Metadata</h3>
  <div id="metadata"></div>
  <div id="map" style="height: 600px; margin-top: 20px;"></div>
  <script type="module">
    import { parquetRead, parquetMetadataAsync } from 'https://cdn.jsdelivr.net/npm/hyparquet';
    import { snappyUncompressor } from 'https://cdn.jsdelivr.net/npm/hysnappy';
    import { compressors as hycompressors } from 'https://cdn.jsdelivr.net/npm/hyparquet-compressors';

    const compressors = {
      ...hycompressors,
      snappy: snappyUncompressor()
    };

    const map = L.map('map').setView([0, 0], 2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors',
    }).addTo(map);

    const loadFile = async (file) => {
      const arrayBuffer = await file.arrayBuffer();
      const metadata = await parquetMetadataAsync(arrayBuffer);
      displayMetadata(metadata);

      const geoColumn = findGeoColumn(metadata);
      if (!geoColumn) {
        alert('No valid geometry column found.');
        return;
      }

      const data = await parquetRead({
        file: arrayBuffer,
        metadata,
        compressors,
      });

      renderGeoData(data[geoColumn]);
    };

    const findGeoColumn = (metadata) => {
      const geoMetadata = metadata.key_value_metadata?.find((kv) => kv.key === 'geo');
      if (!geoMetadata) return null;
      const geo = JSON.parse(geoMetadata.value);
      return geo.columns[geo.primary_column];
    };

    const renderGeoData = (geometryData) => {
      geometryData.forEach((geometry) => {
        const wkt = new TextDecoder('utf-8').decode(geometry);
        const geoJSON = wellknown.parse(wkt);

        if (geoJSON.type === 'Point') {
          L.marker([geoJSON.coordinates[1], geoJSON.coordinates[0]]).addTo(map);
        } else if (geoJSON.type === 'Polygon') {
          L.polygon(geoJSON.coordinates.map((ring) => ring.map(([lng, lat]) => [lat, lng]))).addTo(map);
        } else if (geoJSON.type === 'LineString') {
          L.polyline(geoJSON.coordinates.map(([lng, lat]) => [lat, lng])).addTo(map);
        }
      });
    };

    const displayMetadata = (metadata) => {
      const container = document.getElementById('metadata');
      container.innerHTML = `
        <p><strong>Number of Rows:</strong> ${metadata.num_rows}</p>
        <p><strong>Columns:</strong> ${metadata.schema.fields.map((f) => f.name).join(', ')}</p>
      `;
    };

    document.getElementById('fileInput').addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) loadFile(file);
    });

    document.getElementById('loadButton').addEventListener('click', async () => {
      const url = document.getElementById('urlInput').value;
      if (!url) return;

      const response = await fetch(url);
      const arrayBuffer = await response.arrayBuffer();
      const metadata = await parquetMetadataAsync(arrayBuffer);
      displayMetadata(metadata);

      const geoColumn = findGeoColumn(metadata);
      if (!geoColumn) {
        alert('No valid geometry column found.');
        return;
      }

      const data = await parquetRead({
        file: arrayBuffer,
        metadata,
        compressors,
      });

      renderGeoData(data[geoColumn]);
    });
  </script>
</body>
</html>
