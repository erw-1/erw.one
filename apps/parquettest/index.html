<!DOCTYPE html>
<html>
<head>
  <title>Render GeoParquet on Leaflet</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
  <script src="./wellknown.min.js"></script> <!-- WKT Parser -->
</head>
<body>
  <h1>Load GeoParquet on Leaflet</h1>
  <input type="file" id="fileInput" />
  <br />
  Or load from URL:
  <input type="text" id="urlInput" value="https://example.com/geo.parquet" />
  <button id="loadButton">Load</button>
  <div id="map" style="height: 600px;"></div>
  
  <script type="module">
    import initParquetWasm, { readParquet } from "./parquet_wasm.js";
    import * as arrow from "https://cdn.jsdelivr.net/npm/apache-arrow@10.0.1/+esm";

    const fileInput = document.getElementById("fileInput");
    const urlInput = document.getElementById("urlInput");
    const loadButton = document.getElementById("loadButton");

    const initializeMap = () => {
      const map = L.map("map").setView([0, 0], 2);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: "&copy; OpenStreetMap contributors",
      }).addTo(map);
      return map;
    };

    const renderGeoParquet = async (parquetBytes, map) => {
      console.log("Initializing WebAssembly...");
      await initParquetWasm();

      console.log("Reading Parquet file...");
      const wasmTable = readParquet(parquetBytes, { batchSize: Math.pow(2, 31) });
      const ipcStream = wasmTable.intoIPCStream();
      const arrowTable = arrow.tableFromIPC(ipcStream);

      console.log("Extracting geometries...");
      const geometryColumn = arrowTable.getChild("geometry");
      if (!geometryColumn) {
        console.error("No geometry column found.");
        return;
      }

      const binaryGeometries = geometryColumn.data[0].values;
      if (!binaryGeometries || binaryGeometries.length === 0) {
        console.error("No valid geometries found.");
        return;
      }

      console.log("Rendering geometries...");
      binaryGeometries.forEach((binary) => {
        const wkt = new TextDecoder("utf-8").decode(binary);
        const geometry = wellknown.parse(wkt);

        if (geometry.type === "Point") {
          L.marker([geometry.coordinates[1], geometry.coordinates[0]]).addTo(map);
        } else if (geometry.type === "Polygon") {
          L.polygon(
            geometry.coordinates.map((ring) => ring.map(([lng, lat]) => [lat, lng]))
          ).addTo(map);
        } else if (geometry.type === "LineString") {
          L.polyline(
            geometry.coordinates.map(([lng, lat]) => [lat, lng])
          ).addTo(map);
        } else {
          console.warn(`Unsupported geometry type: ${geometry.type}`);
        }
      });
    };

    const map = initializeMap();

    fileInput.addEventListener("change", async (event) => {
      const file = event.target.files[0];
      if (file) {
        const parquetBytes = new Uint8Array(await file.arrayBuffer());
        renderGeoParquet(parquetBytes, map);
      }
    });

    loadButton.addEventListener("click", async () => {
      const url = urlInput.value;
      if (!url) return;
      const response = await fetch(url);
      if (response.ok) {
        const parquetBytes = new Uint8Array(await response.arrayBuffer());
        renderGeoParquet(parquetBytes, map);
      } else {
        console.error("Failed to fetch file from URL.");
      }
    });
  </script>
</body>
</html>
