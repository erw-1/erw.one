<!DOCTYPE html>
<html>
<head>
  <title>GeoParquet Viewer</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
</head>
<body>
  <h1>GeoParquet Viewer</h1>
  <div>
    <label for="fileInput">Upload GeoParquet file:</label>
    <input type="file" id="fileInput" accept=".parquet" />
    <br />
    <label for="urlInput">Or load from URL:</label>
    <input type="text" id="urlInput" placeholder="Enter GeoParquet URL" />
    <button id="loadUrlButton">Load from URL</button>
  </div>
  <div id="map" style="height: 600px; margin-top: 20px;"></div>

<script type="module">
  import initParquetWasm, { readParquetStream, setWasmMemory } from 'https://unpkg.com/parquet-wasm@0.5.0-alpha.1/esm/arrow1.js';
  import * as apacheArrow from 'https://cdn.jsdelivr.net/npm/apache-arrow@10.0.1/+esm';

  const map = L.map('map').setView([38.8543844, -99.5243335], 4);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; OpenStreetMap contributors',
  }).addTo(map);

  const renderGeoParquet = async (source, isFile = false) => {
    try {
      console.log("Initializing WebAssembly...");
      await setWasmMemory({ initial: 256, maximum: 1024 }); // Increase memory limit
      await initParquetWasm();

      let stream;
      if (isFile) {
        console.log("Processing local file...");
        const asyncBuffer = {
          byteLength: source.byteLength,
          slice: async (start, end) => source.slice(start, end),
        };
        stream = await readParquetStream(asyncBuffer);
      } else {
        console.log("Processing URL...");
        stream = await readParquetStream(source); // URL: Pass directly
      }

      console.log("Rendering GeoParquet...");
      for await (const wasmRecordBatch of stream) {
        const ipcBatch = wasmRecordBatch.intoIPC();
        const table = apacheArrow.tableFromIPC(ipcBatch);

        // Extract geometries (adjust column index as necessary)
        const geometryColumnIdx = 6;
        const recordBatch = table.batches[0];
        const geometryColumn = recordBatch.getChildAt(geometryColumnIdx);

        if (!geometryColumn) {
          console.error("Geometry column not found in the dataset.");
          return;
        }

        const geometryOffsets = geometryColumn.data[0].valueOffsets;
        const flatCoordinateArray = geometryColumn
          .getChildAt(0)
          .getChildAt(0)
          .data[0].values;

        // Render geometries
        for (let i = 0; i < geometryOffsets.length - 1; i++) {
          const start = geometryOffsets[i];
          const end = geometryOffsets[i + 1];
          const coordinates = [];
          for (let j = start; j < end; j++) {
            const lat = flatCoordinateArray[j * 2 + 1];
            const lng = flatCoordinateArray[j * 2];
            coordinates.push([lat, lng]);
          }
          L.polygon(coordinates).addTo(map);
        }
      }
      console.log("Rendering complete!");
    } catch (error) {
      console.error("An error occurred while rendering GeoParquet:", error);
    }
  };

  document.getElementById('fileInput').addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    const arrayBuffer = await file.arrayBuffer();
    const uint8Array = new Uint8Array(arrayBuffer);

    console.log("Uploaded file size:", uint8Array.byteLength);
    renderGeoParquet(uint8Array, true);
  });

  document.getElementById('loadUrlButton').addEventListener('click', () => {
    const url = document.getElementById('urlInput').value;
    if (url) renderGeoParquet(url);
  });
</script>
  <script type="module">
    import initParquetWasm, { readParquetStream, setWasmMemory } from 'https://unpkg.com/parquet-wasm@0.5.0-alpha.1/esm/arrow1.js';
    import * as apacheArrow from 'https://cdn.jsdelivr.net/npm/apache-arrow@10.0.1/+esm';
  
    const map = L.map('map').setView([38.8543844, -99.5243335], 4);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors',
    }).addTo(map);
  
    const renderGeoParquet = async (source, isFile = false) => {
      try {
        console.log("Initializing WebAssembly...");
        await setWasmMemory({ initial: 256, maximum: 1024 }); // Increase memory limit
        await initParquetWasm();
  
        let stream;
        if (isFile) {
          console.log("Processing local file...");
          const asyncBuffer = {
            byteLength: source.byteLength,
            slice: async (start, end) => source.slice(start, end),
          };
          stream = await readParquetStream(asyncBuffer);
        } else {
          console.log("Processing URL...");
          stream = await readParquetStream(source); // URL: Pass directly
        }
  
        console.log("Rendering GeoParquet...");
        for await (const wasmRecordBatch of stream) {
          const ipcBatch = wasmRecordBatch.intoIPC();
          const table = apacheArrow.tableFromIPC(ipcBatch);
  
          // Extract geometries (adjust column index as necessary)
          const geometryColumnIdx = 6;
          const recordBatch = table.batches[0];
          const geometryColumn = recordBatch.getChildAt(geometryColumnIdx);
  
          if (!geometryColumn) {
            console.error("Geometry column not found in the dataset.");
            return;
          }
  
          const geometryOffsets = geometryColumn.data[0].valueOffsets;
          const flatCoordinateArray = geometryColumn
            .getChildAt(0)
            .getChildAt(0)
            .data[0].values;
  
          // Render geometries
          for (let i = 0; i < geometryOffsets.length - 1; i++) {
            const start = geometryOffsets[i];
            const end = geometryOffsets[i + 1];
            const coordinates = [];
            for (let j = start; j < end; j++) {
              const lat = flatCoordinateArray[j * 2 + 1];
              const lng = flatCoordinateArray[j * 2];
              coordinates.push([lat, lng]);
            }
            L.polygon(coordinates).addTo(map);
          }
        }
        console.log("Rendering complete!");
      } catch (error) {
        console.error("An error occurred while rendering GeoParquet:", error);
      }
    };
  
    document.getElementById('fileInput').addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (!file) return;
  
      const arrayBuffer = await file.arrayBuffer();
      const uint8Array = new Uint8Array(arrayBuffer);
  
      console.log("Uploaded file size:", uint8Array.byteLength);
      renderGeoParquet(uint8Array, true);
    });
  
    document.getElementById('loadUrlButton').addEventListener('click', () => {
      const url = document.getElementById('urlInput').value;
      if (url) renderGeoParquet(url);
    });
  </script>

</body>
</html>
