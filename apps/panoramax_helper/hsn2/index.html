<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Suivi GPS – Leaflet (avoid_polygons + logs v2)</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" />

    <style>
        html, body {height: 100%; margin: 0;}
        #map {height: 100%; width: 100%;}
        *{font-family: 'Poppins', sans-serif;}
    
        #search-container {
            width: 320px;
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(255,255,255,0.5);
            backdrop-filter: blur(5px);
            border-radius: 4px;
        }
    
        #addressInput { width: 313px; font-size: 1.2rem; border-radius: 4px; }
        #addressSuggestions { list-style: none; margin: 2px 0 0 0; padding: 0; }
        #addressSuggestions li {
            width: auto; border-radius: 4px; margin-bottom: 1px;
            background: rgba(255,255,255,0.5); border: solid 1px rgba(0,0,0,0.5); cursor: pointer;
        }
        #trackButton {
            position: fixed; bottom: 1rem; left: 50%; transform: translateX(-50%); z-index: 1000;
            background: #fff; border: 2px solid #666; border-radius: 4px; padding: 0.5rem 1rem;
            font-size: 4rem; cursor: pointer; box-shadow: 0 2px 6px rgba(0, 0, 0, .3);
        }
        .leaflet-control-attribution.leaflet-control {display: none;}

        /* Small on‑screen logger */
        #log {
            position: fixed; bottom: 1rem; right: 1rem; z-index: 1500;
            max-width: 360px; background: rgba(0,0,0,0.75); color:#fff;
            padding: .5rem 1rem; border-radius:4px; font-size:.75rem;
            pointer-events: none; white-space: pre-line;
        }
    </style>
</head>
<body>
    <!-- Recherche d'adresse -->
    <div id="search-container">
        <input id="addressInput" type="text" placeholder="Rechercher une adresse…" />
        <ul id="addressSuggestions"></ul>
    </div>
    <!-- Bouton de suivi -->
    <button id="trackButton">Commencer</button>
    <!-- Carte -->
    <div id="map"></div>
    <!-- Petit logger -->
    <div id="log"></div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Plugin VectorTileLayer (UMD) -->
    <script src="https://unpkg.com/leaflet-vector-tile-layer@0.16.1/dist/VectorTileLayer.umd.min.js"></script>
    <!-- Leaflet‑rotate pour la boussole / rotation -->
    <script src="https://unpkg.com/leaflet-rotate@0.2.8/dist/leaflet-rotate-src.js"></script>
    <!-- turf.js pour buffer/union -->
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

    <script>
        // ------------------------------------------------------------------
        // Logger minimal (console + overlay)
        // ------------------------------------------------------------------
        function log(msg) {
            console.log(msg);
            document.getElementById('log').textContent = msg;
        }

        // ------------------------------------------------------------------
        // Clé API OpenRouteService
        // ------------------------------------------------------------------
        const ORS_API_KEY = "5b3ce3597851110001cf624873a9f82e7dce4b46a1e049860a2c461d";

        // ------------------------------------------------------------------
        // Carte de base
        // ------------------------------------------------------------------
        const map = L.map('map', { rotate:true, touchRotate:true, rotateControl:{closeOnZeroBearing:false}, preferCanvas:true }).setView([46.5,2.5],6);
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {maxZoom:19}).addTo(map);

        // ------------------------------------------------------------------
        // Couche Panoramax (vector tile)
        // ------------------------------------------------------------------
        const panoramaxURL = 'https://api.panoramax.xyz/api/users/e4933c0c-653b-429a-833a-f45f64e41726/map/{z}/{x}/{y}.mvt';
        const vtOptions = { filter:f=>f&&f.type===2, style:{ color:'red', weight:3, opacity:1 }, maxDetailZoom:15 };
        let redLayer = null;

        // Créer la couche en tenant compte des trois implémentations possibles du plugin
        if (typeof window.VectorTileLayer === 'function') {
            // UMD : new VectorTileLayer(...)
            redLayer = new VectorTileLayer(panoramaxURL, vtOptions).addTo(map);
            log('VectorTileLayer UMD detected');
        } else if (L && typeof L.vectorTileLayer === 'function') {
            // leaflet.vector-tile-layer ajoute une factory L.vectorTileLayer
            redLayer = L.vectorTileLayer(panoramaxURL, vtOptions).addTo(map);
            log('L.vectorTileLayer factory detected');
        } else if (typeof window.vectorTileLayer === 'function') {
            // global helper (rare)
            redLayer = window.vectorTileLayer(panoramaxURL, vtOptions).addTo(map);
            log('window.vectorTileLayer detected');
        } else {
            log('❌ Aucune implémentation VectorTileLayer trouvée — la couche rouge ne sera pas chargée');
        }

        // ------------------------------------------------------------------
        // ------------------------------------------------------------------
        // ------------------------------------------------------------------
        // Buffer & avoid_polygons – décodage direct des tuiles .mvt
        // ------------------------------------------------------------------
        let avoidPolygon=null, avoidLayer=null; const BUFFER_M=15;

        // librairies de décodage PBF / MVT (chargées dynamiquement la 1re fois)
        let PbfLib=null, VTileLib=null;
        function ensurePbfLibs(){
            return new Promise((resolve,reject)=>{
                if(PbfLib&&VTileLib) return resolve();
                const urlsPrimary=[
                    'https://unpkg.com/pbf@3.2.1/dist/pbf.js',
                    'https://unpkg.com/@mapbox/vector-tile@1.3.1/dist/vector-tile.js'
                ];
                const urlsFallback=[
                    'https://cdn.jsdelivr.net/npm/pbf@3.2.1/dist/pbf.min.js',
                    'https://cdn.jsdelivr.net/npm/@mapbox/vector-tile@1.3.1/dist/vector-tile.min.js'
                ];
                let loaded=0, triedFallback=false;
                function done(){ if(PbfLib&&VTileLib) return resolve(); if(!triedFallback){ triedFallback=true; loadSet(urlsFallback);} else reject('Échec chargement pbf/vector‑tile depuis 2 CDN'); }
                function loadSet(urls){
                    urls.forEach(src=>{
                        const s=document.createElement('script');
                        s.src=src; s.async=true;
                        s.onload=()=>{ if(src.includes('pbf')) PbfLib=window.pbf||window.Pbf; if(src.includes('vector-tile')) VTileLib=window.VectorTile; loaded++; if(loaded%2===0) done(); };
                        s.onerror=()=>{ loaded++; if(loaded%2===0) done(); };
                        document.head.appendChild(s);
                    });
                }
                loadSet(urlsPrimary);
            });
        }

        async function fetchTile(z,x,y){
            const url=panoramaxURL.replace('{z}',z).replace('{x}',x).replace('{y}',y);
            const r=await fetch(url);
            if(!r.ok) throw new Error('HTTP '+r.status);
            const arrayBuffer=await r.arrayBuffer();
            const vt=new VTileLib(new PbfLib(arrayBuffer));
            const feats=[];
            for(const lname in vt.layers){
                const layer=vt.layers[lname];
                for(let i=0;i<layer.length;i++){
                    const feat=layer.feature(i);
                    if(feat.type!==2) continue; // LineString only
                    feats.push(feat.toGeoJSON(x,y,z));
                }
            }
            return feats;
        }

        async function buildAvoidPolygon(){
            try{
                await ensurePbfLibs();
            }catch(e){ log('❌ libs pbf : '+e); return; }
            const bounds=map.getBounds();
            const z=Math.floor(map.getZoom());
            const tile2coord=n=>Math.floor(n);
            const nw=map.project(bounds.getNorthWest(),z).divideBy(256);
            const se=map.project(bounds.getSouthEast(),z).divideBy(256);
            const xMin=tile2coord(nw.x), xMax=tile2coord(se.x);
            const yMin=tile2coord(nw.y), yMax=tile2coord(se.y);
            let feats=[];
            try{
                const promises=[];
                for(let x=xMin;x<=xMax;x++) for(let y=yMin;y<=yMax;y++) promises.push(fetchTile(z,x,y));
                const chunks=await Promise.all(promises);
                chunks.forEach(arr=>feats=feats.concat(arr));
            }catch(err){ log('fetchTile err : '+err); return; }
            if(!feats.length){ log('⚠️ Aucune feature décodée'); return; }
            try{
                let merged=feats[0];
                for(let i=1;i<feats.length;i++) merged=turf.union(merged,feats[i]);
                avoidPolygon=turf.buffer(merged, BUFFER_M/1000,{units:'kilometers'});
                if(avoidLayer) map.removeLayer(avoidLayer);
                avoidLayer=L.geoJSON(avoidPolygon,{style:{color:'#ff7800',weight:1,fillOpacity:0.25}}).addTo(map);
                log('✅ Buffer généré ('+feats.length+' feats, '+(xMax-xMin+1)*(yMax-yMin+1)+' tiles)');
            }catch(err){ log('Buffer error :'+err); }
        }

        map.on('moveend zoomend', ()=>{ buildAvoidPolygon(); });
        // appel initial
        buildAvoidPolygon();

        // ------------------------------------------------------------------
        // Rotation helper
        // ------------------------------------------------------------------
        function clickRotateArrow(){ const a=document.querySelector('span.leaflet-control-rotate-arrow'); if(a) a.click(); }

        // ------------------------------------------------------------------
        // Suivi GPS (auto‑start possible)
        // ------------------------------------------------------------------
        let isTracking=false,watchId=null,currentCoords=[],currentLine=null; const lineWeight=3;
        const trackButton=document.getElementById('trackButton'); trackButton.addEventListener('click',()=>isTracking?stopTracking():startTracking());

        function startTracking(){ if(!navigator.geolocation){alert('Géoloc non supportée');return;} isTracking=true; trackButton.textContent='Terminer'; currentCoords=[]; currentLine=L.polyline([],{color:'blue',weight:lineWeight}).addTo(map); watchId=navigator.geolocation.watchPosition(onPos,onGeoError,{enableHighAccuracy:true,maximumAge:5000,timeout:20000}); clickRotateArrow(); log('Tracking…'); }
        function onPos(pos){ const ll=[pos.coords.latitude,pos.coords.longitude]; currentCoords.push(ll); currentLine.setLatLngs(currentCoords); map.panTo(ll,{animate:false}); }
        function onGeoError(err){ log('Erreur géoloc : '+err.message); alert(err.message); }
        function stopTracking(){ if(watchId!==null) navigator.geolocation.clearWatch(watchId); isTracking=false; trackButton.textContent='Commencer'; if(currentLine) currentLine.setStyle({color:'green'}); currentLine=null; currentCoords=[]; log('Tracking stoppé'); clickRotateArrow(); clickRotateArrow(); }

        // ------------------------------------------------------------------
        // Géocodage + suggestions (ORS) + itinéraire
        // ------------------------------------------------------------------
        let addrRouteLayer=null;
        function geocodeORS(q){ return fetch(`https://api.openrouteservice.org/geocode/autocomplete?api_key=${ORS_API_KEY}&text=${encodeURIComponent(q)}`).then(r=>r.ok?r.json():Promise.reject()).then(d=>(d.features||[]).map(f=>({label:f.properties.label,coords:[f.geometry.coordinates[1],f.geometry.coordinates[0]]}))); }
        function showSuggestions(list){ const c=document.getElementById('addressSuggestions'); c.innerHTML=''; list.forEach(item=>{ const li=document.createElement('li'); li.textContent=item.label; li.onclick=()=>{ c.innerHTML=''; document.getElementById('addressInput').value=item.label; if(!isTracking){ startTracking(); navigator.geolocation.getCurrentPosition(p=>{ currentCoords.push([p.coords.latitude,p.coords.longitude]); routeTo(item.coords); },onGeoError,{enableHighAccuracy:true,timeout:10000}); } else { routeTo(item.coords);} }; c.appendChild(li);} ); }
        document.getElementById('addressInput').addEventListener('input',e=>{ const v=e.target.value; if(v.length<4){showSuggestions([]);return;} geocodeORS(v).then(r=>showSuggestions(r.slice(0,5))).catch(()=>showSuggestions([])); });

        function decodePolyline(str){ let i=0,lat=0,lon=0,coords=[]; while(i<str.length){ let b,shift=0,res=0; do{ b=str.charCodeAt(i++)-63; res|=(b&0x1f)<<shift; shift+=5;}while(b>=0x20); const dlat=((res&1)?~(res>>1):(res>>1)); lat+=dlat; shift=0; res=0; do{ b=str.charCodeAt(i++)-63; res|=(b&0x1f)<<shift; shift+=5;}while(b>=0x20); const dlon=((res&1)?~(res>>1):(res>>1)); lon+=dlon; coords.push([lat/1e5,lon/1e5]);} return coords; }

        function routeTo(dest){ if(currentCoords.length===0){ log('Attente position GPS…'); return;} if(!avoidPolygon) buildAvoidPolygon(); const [lat1,lon1]=currentCoords[currentCoords.length-1]; const [lat2,lon2]=dest; const body={ coordinates:[[lon1,lat1],[lon2,lat2]], language:'fr', instructions:false, options:{}}; if(avoidPolygon) body.options.avoid_polygons=avoidPolygon.geometry; log('Request ORS (avoid '+!!avoidPolygon+')'); fetch('https://api.openrouteservice.org/v2/directions/driving-car',{method:'POST',headers:{'Accept':'application/json','Authorization':ORS_API_KEY,'Content-Type':'application/json'},body:JSON.stringify(body)}).then(r=>r.ok?r.json():Promise.reject('ORS error')).then(data=>{ const coords=decodePolyline(data.routes[0].geometry); if(addrRouteLayer) map.removeLayer(addrRouteLayer); addrRouteLayer=L.geoJSON({type:'LineString',coordinates:coords.map(([la,lo])=>[lo,la])},{style:{color:'#333',weight:4,opacity:0.85}}).addTo(map); map.fitBounds(addrRouteLayer.getBounds(),{padding:[20,20]}); log('Itinéraire '+Math.round(data.routes[0].summary.distance/100)/10+' km'); }).catch(err=>{ log('Échec itinéraire :'+err); alert(err);}); }
    </script>
</body>
</html>
