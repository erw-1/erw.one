<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Suivi GPS – Leaflet</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" />

    <style>
        html, body {height: 100%; margin: 0;}
        #map {height: 100%; width: 100%;}
        * { font-family: 'Poppins', sans-serif; }

        #search-container {
            width: 320px;
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(255,255,255,0.5);
            backdrop-filter: blur(5px);
            border-radius: 4px;
            display: flex;
            flex-direction: column;
        }
        #addressInput {
            width: 100%;
            font-size: 1.2rem;
            padding: 0.5rem;
            border: none;
            border-radius: 4px;
        }
        #addressSuggestions {
            list-style: none;
            margin: 4px 0 0;
            padding: 0;
            max-height: 150px;
            overflow-y: auto;
        }
        #addressSuggestions li {
            padding: 0.5rem;
            margin-bottom: 2px;
            background: rgba(255,255,255,0.7);
            border: 1px solid rgba(0,0,0,0.2);
            border-radius: 4px;
            cursor: pointer;
        }
        #addressSuggestions li:hover {
            background: rgba(255,255,255,1);
        }

        #trackButton {
            position: fixed;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: #fff;
            border: 2px solid #666;
            border-radius: 4px;
            padding: 0.5rem 1rem;
            font-size: 4rem;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, .3);
        }
        .leaflet-control-attribution.leaflet-control {display: none;}
    </style>
</head>
<body>
    <!-- Recherche d'adresse -->
    <div id="search-container">
        <input id="addressInput" type="text" placeholder="Rechercher une adresse…" disabled />
        <ul id="addressSuggestions"></ul>
    </div>
    <!-- Bouton de suivi -->
    <button id="trackButton">Commencer</button>
    <!-- Carte -->
    <div id="map"></div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Plugin VectorTileLayer (UMD) -->
    <script src="https://unpkg.com/leaflet-vector-tile-layer@0.16.1/dist/VectorTileLayer.umd.min.js"></script>
    <!-- Leaflet-rotate -->
    <script src="https://unpkg.com/leaflet-rotate@0.2.8/dist/leaflet-rotate-src.js"></script>
    <!-- Turf.js pour buffer -->
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

    <script>
        // ------------------------------------------------------------------
        // Clé API OpenRouteService
        // ------------------------------------------------------------------
        const ORS_API_KEY = "5b3ce3597851110001cf624873a9f82e7dce4b46a1e049860a2c461d";

        // ------------------------------------------------------------------
        // Carte de base
        // ------------------------------------------------------------------
        const map = L.map('map', { zoomControl:false, rotate:true, touchRotate:true, rotateControl:{closeOnZeroBearing:false}, preferCanvas:true }).setView([46.5,2.5],6);
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',{maxZoom:19, attribution:'&copy; OpenStreetMap contributors'}).addTo(map);

        // ------------------------------------------------------------------
        // Couche Panoramax
        // ------------------------------------------------------------------
        const panoramaxURL='https://api.panoramax.xyz/api/users/e4933c0c-653b-429a-833a-f45f64e41726/map/{z}/{x}/{y}.mvt';
        const vtOptions={filter:f=>f?.type===2, style:{color:'red',weight:3,opacity:1}, maxDetailZoom:15};
        let redLayer;
        if(typeof VectorTileLayer==='function') redLayer=new VectorTileLayer(panoramaxURL,vtOptions).addTo(map);
        else if(window.vectorTileLayer) redLayer=window.vectorTileLayer(panoramaxURL,vtOptions).addTo(map);
        else if(L.vectorTileLayer) redLayer=L.vectorTileLayer(panoramaxURL,vtOptions).addTo(map);
        redLayer?.once('load',()=>{const b=redLayer.getBounds?.(); if(b?.isValid()) map.fitBounds(b);});

        // ------------------------------------------------------------------
        // Rotation
        // ------------------------------------------------------------------
        function clickRotateArrow(){document.querySelector('span.leaflet-control-rotate-arrow')?.click();}

        // ------------------------------------------------------------------
        // Suivi GPS & recherche d'adresse
        // ------------------------------------------------------------------
        let isTracking=false, watchId=null, currentCoords=[], currentLine=null, addrRouteLayer=null;
        const trackButton=document.getElementById('trackButton'), addressInput=document.getElementById('addressInput');
        trackButton.addEventListener('click',()=>isTracking?stopTracking():startTracking());

        function startTracking(){
            if(!navigator.geolocation) return alert('Géolocalisation non supportée');
            isTracking=true; trackButton.textContent='Terminer'; addressInput.disabled=false;
            currentCoords=[]; currentLine=L.polyline([], {color:'blue',weight:3}).addTo(map);
            watchId=navigator.geolocation.watchPosition(onPos,onGeoError,{enableHighAccuracy:true,maximumAge:5000,timeout:20000});
            clickRotateArrow();
        }
        function onPos(pos){ const p=[pos.coords.latitude,pos.coords.longitude]; currentCoords.push(p); currentLine.setLatLngs(currentCoords); map.panTo(p,{animate:false}); }
        function onGeoError(e){ console.error(e); alert('Erreur géoloc: '+e.message); }
        function stopTracking(){
            navigator.geolocation.clearWatch(watchId);
            isTracking=false; trackButton.textContent='Commencer'; addressInput.disabled=true;
            currentLine.setStyle({color:'green'});
            if(currentCoords.length>1) exportGeoJSON(currentCoords);
            currentCoords=[]; currentLine=null; clickRotateArrow(); clickRotateArrow();
        }
        function exportGeoJSON(coords){
            const feat={type:'Feature',properties:{finishedAt:new Date().toISOString()},geometry:{type:'LineString',coordinates:coords.map(c=>[c[1],c[0]])}};
            const blob=new Blob([JSON.stringify({type:'FeatureCollection',features:[feat]})],{type:'application/geo+json'});
            const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url;
            a.download='trace_'+new Date().toISOString().replace(/[:.]/g,'-')+'.geojson'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        }

        addressInput.addEventListener('input',e=>{
            const q=e.target.value; if(!isTracking||q.length<4) return clearSuggestions();
            geocodeORS(q).then(list=>showSuggestions(list.slice(0,5))).catch(clearSuggestions);
        });
        function clearSuggestions(){document.getElementById('addressSuggestions').innerHTML='';}
        function showSuggestions(list){const ul=document.getElementById('addressSuggestions'); ul.innerHTML=''; list.forEach(item=>{const li=document.createElement('li'); li.textContent=item.label; li.onclick=()=>{clearSuggestions(); addressInput.value=item.label; routeToAddress(item.coords);} ; ul.appendChild(li);});}
        function geocodeORS(q){return fetch(`https://api.openrouteservice.org/geocode/autocomplete?api_key=${ORS_API_KEY}&text=${encodeURIComponent(q)}`)
            .then(r=>r.ok?r.json():Promise.reject()).then(d=>d.features.map(f=>({label:f.properties.label,coords:[f.geometry.coordinates[1],f.geometry.coordinates[0]]})));
        }

        // ------------------------------------------------------------------
        // Itinéraire avec avoid_polygons
        // ------------------------------------------------------------------
        function routeToAddress(dest) {
            if(currentCoords.length===0) return alert("Démarrez le suivi d'abord");
            // Construction du buffer autour de la couche Panoramax
            const panofeatures = redLayer.toGeoJSON();
            const buffered = turf.buffer(panofeatures, 500, { units: 'meters' });

            const [lat, lon] = currentCoords[currentCoords.length - 1];
            const body = {
                coordinates: [[lon, lat], [dest[1], dest[0]]],
                profile: 'driving-car',
                format: 'geojson',
                geometries: 'geojson',
                options: { avoid_polygons: buffered.geometry }
            };

            fetch('https://api.openrouteservice.org/v2/directions/driving-car', {
                method: 'POST',
                headers: { 'Authorization': ORS_API_KEY, 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            })
            .then(r => r.ok ? r.json() : Promise.reject())
            .then(data => {
                const feat = data.features[0];
                if (addrRouteLayer) map.removeLayer(addrRouteLayer);
                addrRouteLayer = L.geoJSON(feat, { style:{ color:'#333', weight:4, opacity:0.8 } }).addTo(map);
                map.fitBounds(addrRouteLayer.getBounds(), { padding: [20,20] });
            })
            .catch(() => alert('Impossible de calculer l\'itinéraire'));
        }
    </script>
</body>
</html>
