<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Suivi GPS – Leaflet (avoid_polygons + logs v2)</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" />

    <style>
        html, body {height: 100%; margin: 0;}
        #map {height: 100%; width: 100%;}
        *{font-family: 'Poppins', sans-serif;}
    
        #search-container {
            width: 320px;
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(255,255,255,0.5);
            backdrop-filter: blur(5px);
            border-radius: 4px;
        }
    
        #addressInput { width: 313px; font-size: 1.2rem; border-radius: 4px; }
        #addressSuggestions { list-style: none; margin: 2px 0 0 0; padding: 0; }
        #addressSuggestions li {
            width: auto; border-radius: 4px; margin-bottom: 1px;
            background: rgba(255,255,255,0.5); border: solid 1px rgba(0,0,0,0.5); cursor: pointer;
        }
        #trackButton {
            position: fixed; bottom: 1rem; left: 50%; transform: translateX(-50%); z-index: 1000;
            background: #fff; border: 2px solid #666; border-radius: 4px; padding: 0.5rem 1rem;
            font-size: 4rem; cursor: pointer; box-shadow: 0 2px 6px rgba(0, 0, 0, .3);
        }
        .leaflet-control-attribution.leaflet-control {display: none;}

        /* Small on‑screen logger */
        #log {
            position: fixed; bottom: 1rem; right: 1rem; z-index: 1500;
            max-width: 360px; background: rgba(0,0,0,0.75); color:#fff;
            padding: .5rem 1rem; border-radius:4px; font-size:.75rem;
            pointer-events: none; white-space: pre-line;
        }
    </style>
</head>
<body>
    <!-- Recherche d'adresse -->
    <div id="search-container">
        <input id="addressInput" type="text" placeholder="Rechercher une adresse…" />
        <ul id="addressSuggestions"></ul>
    </div>
    <!-- Bouton de suivi -->
    <button id="trackButton">Commencer</button>
    <!-- Carte -->
    <div id="map"></div>
    <!-- Petit logger -->
    <div id="log"></div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Plugin VectorTileLayer (UMD) -->
    <script src="https://unpkg.com/leaflet-vector-tile-layer@0.16.1/dist/VectorTileLayer.umd.min.js"></script>
    <!-- Leaflet‑rotate pour la boussole / rotation -->
    <script src="https://unpkg.com/leaflet-rotate@0.2.8/dist/leaflet-rotate-src.js"></script>
    <!-- turf.js pour buffer/union -->
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

    <script>
        // ------------------------------------------------------------------
        // Logger minimal (console + overlay)
        // ------------------------------------------------------------------
        function log(msg) {
            console.log(msg);
            document.getElementById('log').textContent = msg;
        }

        // ------------------------------------------------------------------
        // Clé API OpenRouteService
        // ------------------------------------------------------------------
        const ORS_API_KEY = "5b3ce3597851110001cf624873a9f82e7dce4b46a1e049860a2c461d";

        // ------------------------------------------------------------------
        // Carte de base
        // ------------------------------------------------------------------
        const map = L.map('map', { rotate:true, touchRotate:true, rotateControl:{closeOnZeroBearing:false}, preferCanvas:true }).setView([46.5,2.5],6);
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {maxZoom:19}).addTo(map);

        // ------------------------------------------------------------------
        // Couche Panoramax (vector tile)
        // ------------------------------------------------------------------
        const panoramaxURL = 'https://api.panoramax.xyz/api/users/e4933c0c-653b-429a-833a-f45f64e41726/map/{z}/{x}/{y}.mvt';
        const vtOptions = { filter:f=>f&&f.type===2, style:{ color:'red', weight:3, opacity:1 }, maxDetailZoom:15 };
        let redLayer = null;

        // Créer la couche en tenant compte des trois implémentations possibles du plugin
        if (typeof window.VectorTileLayer === 'function') {
            // UMD : new VectorTileLayer(...)
            redLayer = new VectorTileLayer(panoramaxURL, vtOptions).addTo(map);
            log('VectorTileLayer UMD detected');
        } else if (L && typeof L.vectorTileLayer === 'function') {
            // leaflet.vector-tile-layer ajoute une factory L.vectorTileLayer
            redLayer = L.vectorTileLayer(panoramaxURL, vtOptions).addTo(map);
            log('L.vectorTileLayer factory detected');
        } else if (typeof window.vectorTileLayer === 'function') {
            // global helper (rare)
            redLayer = window.vectorTileLayer(panoramaxURL, vtOptions).addTo(map);
            log('window.vectorTileLayer detected');
        } else {
            log('❌ Aucune implémentation VectorTileLayer trouvée — la couche rouge ne sera pas chargée');
        }

        // ------------------------------------------------------------------
        // Buffer & avoid_polygons & avoid_polygons
        // ------------------------------------------------------------------
        let avoidPolygon=null, avoidLayer=null; const BUFFER_M=15;

        // Utilitaire : extrait les GeoJSON d'une VectorTileLayer même sans toGeoJSON()
        function extractGeoJSONFeatures(vtl) {
            const feats=[];
            if(!vtl||!vtl._vectorTiles) return feats;
            for(const k in vtl._vectorTiles){
                const t=vtl._vectorTiles[k];
                if(!t.layers) continue;
                for(const lname in t.layers){
                    const l=t.layers[lname];
                    if(!l.features) continue;
                    l.features.forEach(f=>{
                        // include only LineString (type 2) like filter
                        if(f.type!==2) return;
                        const gj=f.toGeoJSON(t.coords.x,t.coords.y,t.coords.z);
                        feats.push(gj);
                    });
                }
            }
            return feats;
        }

        function buildAvoidPolygon(){
            const feats = redLayer.toGeoJSON ? redLayer.toGeoJSON().features : extractGeoJSONFeatures(redLayer);
            if(!feats||!feats.length){ log('Buffer : aucune géométrie (tiles pas chargées)'); return; }
            let merged=feats[0];
            for(let i=1;i<feats.length;i++) merged=turf.union(merged,feats[i]);
            avoidPolygon=turf.buffer(merged, BUFFER_M/1000, {units:'kilometers'});
            if(avoidLayer) map.removeLayer(avoidLayer);
            avoidLayer=L.geoJSON(avoidPolygon,{style:{color:'#ff7800',weight:1,fillOpacity:0.25}}).addTo(map);
            log('Buffer généré avec '+feats.length+' feature(s)');
        }

        if(redLayer){
            // Reconstruire le buffer après chaque batch de tuiles chargées
            redLayer.on('load', ()=>{buildAvoidPolygon();});
            // essayer aussi après 2 s pour être sûr
            setTimeout(buildAvoidPolygon,2000);
        }

        // ------------------------------------------------------------------
        // Rotation helper
        // ------------------------------------------------------------------
        function clickRotateArrow(){ const a=document.querySelector('span.leaflet-control-rotate-arrow'); if(a) a.click(); }

        // ------------------------------------------------------------------
        // Suivi GPS (auto‑start possible)
        // ------------------------------------------------------------------
        let isTracking=false,watchId=null,currentCoords=[],currentLine=null; const lineWeight=3;
        const trackButton=document.getElementById('trackButton'); trackButton.addEventListener('click',()=>isTracking?stopTracking():startTracking());

        function startTracking(){ if(!navigator.geolocation){alert('Géoloc non supportée');return;} isTracking=true; trackButton.textContent='Terminer'; currentCoords=[]; currentLine=L.polyline([],{color:'blue',weight:lineWeight}).addTo(map); watchId=navigator.geolocation.watchPosition(onPos,onGeoError,{enableHighAccuracy:true,maximumAge:5000,timeout:20000}); clickRotateArrow(); log('Tracking…'); }
        function onPos(pos){ const ll=[pos.coords.latitude,pos.coords.longitude]; currentCoords.push(ll); currentLine.setLatLngs(currentCoords); map.panTo(ll,{animate:false}); }
        function onGeoError(err){ log('Erreur géoloc : '+err.message); alert(err.message); }
        function stopTracking(){ if(watchId!==null) navigator.geolocation.clearWatch(watchId); isTracking=false; trackButton.textContent='Commencer'; if(currentLine) currentLine.setStyle({color:'green'}); currentLine=null; currentCoords=[]; log('Tracking stoppé'); clickRotateArrow(); clickRotateArrow(); }

        // ------------------------------------------------------------------
        // Géocodage + suggestions (ORS) + itinéraire
        // ------------------------------------------------------------------
        let addrRouteLayer=null;
        function geocodeORS(q){ return fetch(`https://api.openrouteservice.org/geocode/autocomplete?api_key=${ORS_API_KEY}&text=${encodeURIComponent(q)}`).then(r=>r.ok?r.json():Promise.reject()).then(d=>(d.features||[]).map(f=>({label:f.properties.label,coords:[f.geometry.coordinates[1],f.geometry.coordinates[0]]}))); }
        function showSuggestions(list){ const c=document.getElementById('addressSuggestions'); c.innerHTML=''; list.forEach(item=>{ const li=document.createElement('li'); li.textContent=item.label; li.onclick=()=>{ c.innerHTML=''; document.getElementById('addressInput').value=item.label; if(!isTracking){ startTracking(); navigator.geolocation.getCurrentPosition(p=>{ currentCoords.push([p.coords.latitude,p.coords.longitude]); routeTo(item.coords); },onGeoError,{enableHighAccuracy:true,timeout:10000}); } else { routeTo(item.coords);} }; c.appendChild(li);} ); }
        document.getElementById('addressInput').addEventListener('input',e=>{ const v=e.target.value; if(v.length<4){showSuggestions([]);return;} geocodeORS(v).then(r=>showSuggestions(r.slice(0,5))).catch(()=>showSuggestions([])); });

        function decodePolyline(str){ let i=0,lat=0,lon=0,coords=[]; while(i<str.length){ let b,shift=0,res=0; do{ b=str.charCodeAt(i++)-63; res|=(b&0x1f)<<shift; shift+=5;}while(b>=0x20); const dlat=((res&1)?~(res>>1):(res>>1)); lat+=dlat; shift=0; res=0; do{ b=str.charCodeAt(i++)-63; res|=(b&0x1f)<<shift; shift+=5;}while(b>=0x20); const dlon=((res&1)?~(res>>1):(res>>1)); lon+=dlon; coords.push([lat/1e5,lon/1e5]);} return coords; }

        function routeTo(dest){ if(currentCoords.length===0){ log('Attente position GPS…'); return;} if(!avoidPolygon) buildAvoidPolygon(); const [lat1,lon1]=currentCoords[currentCoords.length-1]; const [lat2,lon2]=dest; const body={ coordinates:[[lon1,lat1],[lon2,lat2]], language:'fr', instructions:false, options:{}}; if(avoidPolygon) body.options.avoid_polygons=avoidPolygon.geometry; log('Request ORS (avoid '+!!avoidPolygon+')'); fetch('https://api.openrouteservice.org/v2/directions/driving-car',{method:'POST',headers:{'Accept':'application/json','Authorization':ORS_API_KEY,'Content-Type':'application/json'},body:JSON.stringify(body)}).then(r=>r.ok?r.json():Promise.reject('ORS error')).then(data=>{ const coords=decodePolyline(data.routes[0].geometry); if(addrRouteLayer) map.removeLayer(addrRouteLayer); addrRouteLayer=L.geoJSON({type:'LineString',coordinates:coords.map(([la,lo])=>[lo,la])},{style:{color:'#333',weight:4,opacity:0.85}}).addTo(map); map.fitBounds(addrRouteLayer.getBounds(),{padding:[20,20]}); log('Itinéraire '+Math.round(data.routes[0].summary.distance/100)/10+' km'); }).catch(err=>{ log('Échec itinéraire :'+err); alert(err);}); }
    </script>
</body>
</html>
