<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Suivi GPS – Leaflet</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <!-- Google Fonts – Poppins -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet" />

  <style>
    :root {
      --blur-bg: hsla(0 0% 100% / .6);
      --border: hsla(220 9% 46% / .4);
      --radius: .5rem;
      --shadow: 0 2px 6px rgb(0 0 0 / .3);
      --accent: #0a84ff;
    }

    *, ::before, ::after {box-sizing: border-box; font-family: 'Poppins', sans-serif;}
    html, body {height: 100%; margin: 0;}
    #map {height: 100%; width: 100%;}

    /* --- Recherche adresse --- */
    #search-container {
      position: fixed; inset: 1rem auto auto 50%; translate: -50% 0;
      width: min(90vw, 320px); z-index: 1000;
      backdrop-filter: blur(8px);
      background: var(--blur-bg); border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: .25rem;
    }

    #addressInput {
      width: 100%; border: 1px solid var(--border); border-radius: var(--radius);
      font-size: 1rem; padding: .4rem .5rem;
    }

    #addressSuggestions {
      list-style: none; margin: .25rem 0 0; padding: 0;
      max-height: 10rem; overflow-y: auto;
    }

    #addressSuggestions li {
      padding: .4rem .5rem; border-radius: var(--radius); cursor: pointer;
    }
    #addressSuggestions li:hover {background: var(--accent); color:#fff;}

    /* --- Bouton tracking --- */
    #trackButton {
      position: fixed; inset: auto auto 1rem 50%; translate: -50% 0;
      z-index: 1000; font-size: 1.25rem; font-weight: 700;
      border: 2px solid var(--border); border-radius: var(--radius);
      background: var(--blur-bg); padding: 0.6rem 1.25rem;
      box-shadow: var(--shadow); cursor: pointer;
    }

    .leaflet-control-attribution.leaflet-control {display:none;}
  </style>
</head>
<body>
  <!-- Recherche d'adresse -->
  <div id="search-container">
    <input id="addressInput" type="text" placeholder="Rechercher une adresse…" autocomplete="off" />
    <ul id="addressSuggestions"></ul>
  </div>

  <!-- Bouton de suivi -->
  <button id="trackButton">Commencer</button>

  <!-- Carte -->
  <div id="map"></div>

  <!-- Leaflet JS et plugins -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" defer></script>
  <script src="https://unpkg.com/leaflet-vector-tile-layer@0.16.1/dist/VectorTileLayer.umd.min.js" defer></script>
  <script src="https://unpkg.com/leaflet-rotate@0.2.8/dist/leaflet-rotate-src.js" defer></script>

  <!-- Notre script principal (module) -->
  <script type="module">
    // ------------------------------------------------------------
    // Constantes & helpers
    // ------------------------------------------------------------
    const ORS_API_KEY = '5b3ce3597851110001cf624873a9f82e7dce4b46a1e049860a2c461d';

    const $ = sel => document.querySelector(sel);
    const $$ = sel => document.querySelectorAll(sel);

    const debounce = (fn, delay = 300) => {
      let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), delay); };
    };

    const fetchJson = async (...args) => {
      const r = await fetch(...args);
      if (!r.ok) throw new Error(`${r.status} : ${r.statusText}`);
      return r.json();
    };

    // ------------------------------------------------------------
    // Carte et couche de base
    // ------------------------------------------------------------
    const map = L.map('map', {
      zoomControl: false,
      rotate: true,
      touchRotate: true,
      rotateControl: { closeOnZeroBearing: false },
      preferCanvas: true,
    }).setView([46.5, 2.5], 6);

    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
      maxZoom: 19,
      attribution: '© OpenStreetMap, © CartoDB',
    }).addTo(map);

    // Couche Panoramax (vector tiles)
    (function addPanoramax() {
      const URL = 'https://api.panoramax.xyz/api/users/e4933c0c-653b-429a-833a-f45f64e41726/map/{z}/{x}/{y}.mvt';
      const opts = { maxDetailZoom: 15, filter: f => f?.type === 2, style: { color: 'red', weight: 3, opacity: 1 } };
      const layerCtor = window.VectorTileLayer || window.vectorTileLayer || (L && L.vectorTileLayer);
      if (!layerCtor) return;
      const layer = layerCtor(URL, opts).addTo(map);
      layer.once('load', () => {
        const b = layer.getBounds?.();
        if (b?.isValid()) map.fitBounds(b);
      });
    }());

    // ------------------------------------------------------------
    // Rotation utilitaire (double‑click pour réinitialiser)
    // ------------------------------------------------------------
    const clickRotateArrow = () => $('span.leaflet-control-rotate-arrow')?.click();

    // ------------------------------------------------------------
    // Tracking GPS
    // ------------------------------------------------------------
    let isTracking = false;
    let watchId = null;
    let currentCoords = [];
    let currentLine = null;
    const lineWeight = 3;

    $('#trackButton').addEventListener('click', () => isTracking ? stopTracking() : startTracking());

    const startTracking = () => {
      if (!navigator.geolocation) return alert('La géolocalisation n\'est pas supportée.');
      isTracking = true;
      $('#trackButton').textContent = 'Terminer';
      currentCoords = [];
      currentLine = L.polyline([], { color: 'blue', weight: lineWeight }).addTo(map);
      watchId = navigator.geolocation.watchPosition(onPos, onGeoError, {
        enableHighAccuracy: true,
        maximumAge: 5000,
        timeout: 20000,
      });
      clickRotateArrow();
    };

    const stopTracking = () => {
      navigator.geolocation.clearWatch(watchId);
      isTracking = false;
      $('#trackButton').textContent = 'Commencer';
      if (currentLine) currentLine.setStyle({ color: 'green' });
      if (currentCoords.length > 1) exportGeoJSON(currentCoords);
      currentCoords = [];
      currentLine = null;
      clickRotateArrow(); clickRotateArrow();
    };

    const onPos = ({ coords }) => {
      const latlng = [coords.latitude, coords.longitude];
      currentCoords.push(latlng);
      currentLine.setLatLngs(currentCoords);
      map.panTo(latlng, { animate: false });
    };

    const onGeoError = err => alert(`Erreur géoloc : ${err.message}`);

    const exportGeoJSON = coords => {
      const feature = {
        type: 'Feature',
        properties: { finishedAt: new Date().toISOString() },
        geometry: { type: 'LineString', coordinates: coords.map(([lat, lon]) => [lon, lat]) },
      };
      const blob = new Blob([JSON.stringify({ type: 'FeatureCollection', features: [feature] })], { type: 'application/geo+json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `trace_${new Date().toISOString().replace(/[T:.]/g, '-')}.geojson`;
      a.click();
      URL.revokeObjectURL(url);
    };

    // ------------------------------------------------------------
    // Géocodage + itinéraire OpenRouteService
    // ------------------------------------------------------------
    const $input = $('#addressInput');
    const $suggest = $('#addressSuggestions');
    let routeLayer = null;

    const geocodeORS = async query => {
      const url = `https://api.openrouteservice.org/geocode/autocomplete?api_key=${ORS_API_KEY}&text=${encodeURIComponent(query)}`;
      const data = await fetchJson(url);
      return (data.features ?? []).map(f => ({ label: f.properties.label, coords: [f.geometry.coordinates[1], f.geometry.coordinates[0]] }));
    };

    const showSuggestions = list => {
      $suggest.innerHTML = '';
      list.forEach(({ label, coords }) => {
        const li = document.createElement('li');
        li.textContent = label;
        li.onclick = () => {
          $suggest.innerHTML = '';
          $input.value = label;
          routeTo(coords);
        };
        $suggest.appendChild(li);
      });
    };

    $input.addEventListener('input', debounce(async e => {
      const val = e.target.value.trim();
      if (val.length < 4) return showSuggestions([]);
      try { showSuggestions((await geocodeORS(val)).slice(0, 3)); }
      catch { showSuggestions([]); }
    }));

    const decodePolyline = str => {
      let idx = 0, lat = 0, lon = 0, pts = [];
      while (idx < str.length) {
        let b, shift = 0, result = 0;
        do { b = str.charCodeAt(idx++) - 63; result |= (b & 0x1f) << shift; shift += 5; } while (b >= 0x20);
        lat += (result & 1 ? ~(result >> 1) : result >> 1);
        shift = 0; result = 0;
        do { b = str.charCodeAt(idx++) - 63; result |= (b & 0x1f) << shift; shift += 5; } while (b >= 0x20);
        lon += (result & 1 ? ~(result >> 1) : result >> 1);
        pts.push([lat / 1e5, lon / 1e5]);
      }
      return pts;
    };

    const routeTo = async ([lat2, lon2]) => {
      if (!currentCoords.length) return alert('Démarrez d\'abord le suivi pour obtenir votre position.');
      const [lat1, lon1] = currentCoords.at(-1);
      const body = JSON.stringify({ coordinates: [[lon1, lat1], [lon2, lat2]], language: 'fr', instructions: false });
      try {
        const data = await fetchJson('https://api.openrouteservice.org/v2/directions/driving-car', {
          method: 'POST',
          headers: {
            'Accept': 'application/json, application/geo+json',
            'Authorization': ORS_API_KEY,
            'Content-Type': 'application/json',
          },
          body,
        });
        const coords = decodePolyline(data.routes[0].geometry).map(([la, lo]) => [lo, la]);
        routeLayer?.remove();
        routeLayer = L.polyline(coords, { color: '#333', weight: 4, opacity: .8 }).addTo(map);
        map.fitBounds(routeLayer.getBounds(), { padding: [20, 20] });
      } catch (err) { alert(err.message || err); }
    };
  </script>
</body>
</html>
